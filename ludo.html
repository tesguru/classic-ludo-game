<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Classic Ludo 3D - Traditional Rules</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Righteous&family=Poppins:wght@300;400;600;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --red: #ff3b3b;
            --green: #06d6a0;
            --yellow: #ffd93d;
            --blue: #4d9de0;
            --dark: #1a1a2e;
            --darker: #0f0f1e;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background: radial-gradient(circle at center, #1a1a2e 0%, #0f0f1e 100%);
            color: white;
            overflow: hidden;
            height: 100vh;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #game-title {
            position: fixed;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Righteous', sans-serif;
            font-size: 2.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, #ffd93d, #ff3b3b, #4d9de0, #06d6a0);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientFlow 4s ease infinite;
            z-index: 10;
            text-shadow: 0 0 30px rgba(255, 217, 61, 0.5);
        }

        @keyframes gradientFlow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        #player-info {
            position: fixed;
            top: 80px;
            left: 20px;
            background: rgba(26, 26, 46, 0.9);
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255, 255, 255, 0.15);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
            z-index: 10;
            min-width: 220px;
        }

        .section-title {
            font-size: 1rem;
            font-weight: 700;
            margin-bottom: 12px;
            color: #ffd93d;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .player-item {
            display: flex;
            align-items: center;
            margin: 10px 0;
            padding: 10px;
            border-radius: 8px;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.05);
        }

        .player-item.active {
            background: rgba(255, 217, 61, 0.2);
            transform: translateX(3px);
            box-shadow: 0 3px 15px rgba(255, 217, 61, 0.4);
            border-left: 3px solid #ffd93d;
        }

        .player-color {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            margin-right: 12px;
            box-shadow: 0 0 15px currentColor;
            border: 2px solid white;
        }

        .player-name {
            font-weight: 600;
            font-size: 0.95rem;
            flex: 1;
        }

        .player-home-count {
            font-size: 0.85rem;
            color: #ffd93d;
            font-weight: 700;
            background: rgba(255, 217, 61, 0.2);
            padding: 3px 8px;
            border-radius: 5px;
        }

        #dice-container {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 10;
        }

        #dice-button {
            width: 120px;
            height: 120px;
            border-radius: 20px;
            background: linear-gradient(145deg, rgba(255, 217, 61, 0.3), rgba(255, 59, 59, 0.2));
            border: 3px solid #ffd93d;
            color: white;
            font-size: 3.5rem;
            cursor: pointer;
            box-shadow: 0 10px 30px rgba(255, 217, 61, 0.5);
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        #dice-button:hover:not(:disabled) {
            transform: scale(1.08);
            box-shadow: 0 15px 40px rgba(255, 217, 61, 0.7);
        }

        #dice-button:active:not(:disabled) {
            transform: scale(0.95);
        }

        #dice-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #dice-button.rolling {
            animation: diceRoll 0.5s ease-in-out;
        }

        @keyframes diceRoll {
            0%, 100% { transform: rotate(0deg) scale(1); }
            25% { transform: rotate(90deg) scale(1.15); }
            50% { transform: rotate(180deg) scale(1); }
            75% { transform: rotate(270deg) scale(1.15); }
        }

        #dice-result {
            margin-top: 10px;
            font-size: 1.3rem;
            font-weight: 700;
            color: #ffd93d;
        }

        #game-status {
            position: fixed;
            top: 80px;
            right: 20px;
            background: rgba(26, 26, 46, 0.9);
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255, 255, 255, 0.15);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
            z-index: 10;
            min-width: 280px;
            max-width: 320px;
        }

        .status-text {
            font-size: 0.95rem;
            line-height: 1.5;
            color: rgba(255, 255, 255, 0.95);
        }

        #rules-panel {
            position: fixed;
            bottom: 30px;
            right: 20px;
            background: rgba(26, 26, 46, 0.9);
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255, 255, 255, 0.15);
            border-radius: 15px;
            padding: 18px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
            z-index: 10;
            max-width: 320px;
            max-height: 280px;
            overflow-y: auto;
        }

        .rules-content {
            font-size: 0.85rem;
            line-height: 1.6;
            color: rgba(255, 255, 255, 0.85);
        }

        .rules-content li {
            margin: 6px 0;
            padding-left: 5px;
        }

        .rules-content strong {
            color: #ffd93d;
        }

        #winner-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.92);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
            animation: fadeIn 0.4s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .winner-content {
            text-align: center;
            background: linear-gradient(135deg, rgba(26, 26, 46, 0.98), rgba(15, 15, 30, 0.98));
            padding: 50px 60px;
            border-radius: 25px;
            border: 3px solid #ffd93d;
            box-shadow: 0 20px 60px rgba(255, 217, 61, 0.5);
            animation: scaleIn 0.5s ease;
        }

        @keyframes scaleIn {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .winner-title {
            font-family: 'Righteous', sans-serif;
            font-size: 3.5rem;
            font-weight: 900;
            background: linear-gradient(45deg, #ffd93d, white, #ffd93d);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientFlow 2s ease infinite;
            margin-bottom: 20px;
        }

        .winner-player {
            font-size: 2rem;
            font-weight: 700;
            margin: 20px 0;
        }

        #restart-button {
            margin-top: 30px;
            padding: 15px 40px;
            background: linear-gradient(135deg, #ffd93d, #ff3b3b);
            border: none;
            border-radius: 12px;
            font-size: 1.2rem;
            font-weight: 700;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 8px 25px rgba(255, 217, 61, 0.4);
            text-transform: uppercase;
        }

        #restart-button:hover {
            transform: scale(1.08);
            box-shadow: 0 12px 35px rgba(255, 217, 61, 0.6);
        }

        .instruction-hint {
            position: fixed;
            bottom: 170px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 217, 61, 0.9);
            color: #1a1a2e;
            padding: 12px 24px;
            border-radius: 10px;
            font-weight: 600;
            font-size: 0.95rem;
            z-index: 10;
            animation: pulse 2s ease-in-out infinite;
            display: none;
        }

        @keyframes pulse {
            0%, 100% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.05); }
        }

        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: #ffd93d;
            border-radius: 10px;
        }

        @media (max-width: 1024px) {
            #game-title { font-size: 1.8rem; }
            #player-info, #game-status, #rules-panel { 
                font-size: 0.85rem; 
                padding: 15px;
                min-width: 180px;
            }
            #dice-button { width: 90px; height: 90px; font-size: 2.5rem; }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <h1 id="game-title">üé≤ CLASSIC LUDO 3D üé≤</h1>

    <div id="player-info">
        <div class="section-title">Players</div>
        <div id="players-list"></div>
    </div>

    <div id="game-status">
        <div class="section-title">Status</div>
        <div class="status-text" id="status-text">Red Player: Roll the dice to start!</div>
    </div>

    <div id="dice-container">
        <button id="dice-button">üé≤</button>
        <div id="dice-result"></div>
    </div>

    <div class="instruction-hint" id="instruction-hint">
        Click on a piece to move it!
    </div>

    <div id="rules-panel">
        <div class="section-title">How to Play</div>
        <div class="rules-content">
            <ul style="list-style: none; padding: 0;">
                <li>üéØ <strong>Goal:</strong> Get all 4 pieces from home to the finish area (center)</li>
                <li>üé≤ <strong>Starting:</strong> Roll a 6 to bring a piece out of home</li>
                <li>‚ÜóÔ∏è <strong>Moving:</strong> Click on your pieces to move them by the dice number</li>
                <li>‚öîÔ∏è <strong>Capture:</strong> Land on opponent pieces to send them back home</li>
                <li>üîÑ <strong>Bonus:</strong> Roll 6 = get another turn!</li>
                <li>üèÅ <strong>Home Stretch:</strong> Enter your colored path to reach the finish</li>
                <li>‚ú® <strong>Winning:</strong> First to get all 4 pieces to finish wins!</li>
            </ul>
        </div>
    </div>

    <div id="winner-modal">
        <div class="winner-content">
            <div class="winner-title">üèÜ WINNER! üèÜ</div>
            <div class="winner-player" id="winner-name"></div>
            <button id="restart-button">Play Again</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game Constants
        const COLORS = {
            RED: { hex: 0xff3b3b, name: 'Red', css: '#ff3b3b' },
            GREEN: { hex: 0x06d6a0, name: 'Green', css: '#06d6a0' },
            YELLOW: { hex: 0xffd93d, name: 'Yellow', css: '#ffd93d' },
            BLUE: { hex: 0x4d9de0, name: 'Blue', css: '#4d9de0' }
        };

        // Ludo Board Path Definition
        // Path starts from each player's starting square and goes around the board
        // Then enters the home stretch (colored column to center)
        
        const BOARD_PATHS = {
            RED: [
                // Starting square and main path
                [6,1], [5,1], [4,1], [3,1], [2,1], [1,1], [0,1],
                [0,2], [0,3], [0,4], [0,5], [0,6], [1,6], [2,6],
                [2,7], [2,8], [1,8], [0,8], [0,9], [0,10], [0,11], [0,12], [0,13],
                [1,13], [2,13], [3,13], [4,13], [5,13], [6,13],
                [6,14], [7,14], [8,14],
                [8,13], [9,13], [10,13], [11,13], [12,13], [13,13], [14,13],
                [14,12], [14,11], [14,10], [14,9], [14,8], [13,8], [12,8],
                [12,7], [12,6], [13,6], [14,6], [14,5], [14,4], [14,3], [14,2], [14,1],
                [13,1], [12,1], [11,1], [10,1], [9,1], [8,1],
                [8,0], [7,0], [6,0],
                // Home stretch (red column)
                [6,1], [6,2], [6,3], [6,4], [6,5], [6,6], [6,7]  // Finish at [6,7]
            ],
            GREEN: [
                // Green starts at [1,8]
                [1,8], [0,8], [0,9], [0,10], [0,11], [0,12], [0,13],
                [1,13], [2,13], [3,13], [4,13], [5,13], [6,13],
                [6,14], [7,14], [8,14],
                [8,13], [9,13], [10,13], [11,13], [12,13], [13,13], [14,13],
                [14,12], [14,11], [14,10], [14,9], [14,8], [13,8], [12,8],
                [12,7], [12,6], [13,6], [14,6], [14,5], [14,4], [14,3], [14,2], [14,1],
                [13,1], [12,1], [11,1], [10,1], [9,1], [8,1],
                [8,0], [7,0], [6,0],
                [6,1], [5,1], [4,1], [3,1], [2,1], [1,1], [0,1],
                [0,2], [0,3], [0,4], [0,5], [0,6], [1,6], [2,6],
                [2,7],
                // Green home stretch
                [1,7], [2,7], [3,7], [4,7], [5,7], [6,7], [7,7]
            ],
            YELLOW: [
                // Yellow starts at [8,13]
                [8,13], [9,13], [10,13], [11,13], [12,13], [13,13], [14,13],
                [14,12], [14,11], [14,10], [14,9], [14,8], [13,8], [12,8],
                [12,7], [12,6], [13,6], [14,6], [14,5], [14,4], [14,3], [14,2], [14,1],
                [13,1], [12,1], [11,1], [10,1], [9,1], [8,1],
                [8,0], [7,0], [6,0],
                [6,1], [5,1], [4,1], [3,1], [2,1], [1,1], [0,1],
                [0,2], [0,3], [0,4], [0,5], [0,6], [1,6], [2,6],
                [2,7], [2,8], [1,8], [0,8], [0,9], [0,10], [0,11], [0,12], [0,13],
                [1,13], [2,13], [3,13], [4,13], [5,13], [6,13],
                [6,14], [7,14], [8,14],
                [8,13],
                // Yellow home stretch
                [8,12], [8,11], [8,10], [8,9], [8,8], [8,7], [7,7]
            ],
            BLUE: [
                // Blue starts at [13,6]
                [13,6], [14,6], [14,5], [14,4], [14,3], [14,2], [14,1],
                [13,1], [12,1], [11,1], [10,1], [9,1], [8,1],
                [8,0], [7,0], [6,0],
                [6,1], [5,1], [4,1], [3,1], [2,1], [1,1], [0,1],
                [0,2], [0,3], [0,4], [0,5], [0,6], [1,6], [2,6],
                [2,7], [2,8], [1,8], [0,8], [0,9], [0,10], [0,11], [0,12], [0,13],
                [1,13], [2,13], [3,13], [4,13], [5,13], [6,13],
                [6,14], [7,14], [8,14],
                [8,13], [9,13], [10,13], [11,13], [12,13], [13,13], [14,13],
                [14,12], [14,11], [14,10], [14,9], [14,8], [13,8], [12,8],
                [12,7],
                // Blue home stretch
                [13,7], [12,7], [11,7], [10,7], [9,7], [8,7], [7,7]
            ]
        };

        const PLAYERS = [
            { 
                id: 0, 
                name: 'Red Player', 
                color: COLORS.RED,
                homePositions: [[1,1],[1,2],[2,1],[2,2]],
                startSquare: [6,1],
                path: BOARD_PATHS.RED,
                finishPosition: [6,7]
            },
            { 
                id: 1, 
                name: 'Green Player', 
                color: COLORS.GREEN,
                homePositions: [[1,12],[1,13],[2,12],[2,13]],
                startSquare: [1,8],
                path: BOARD_PATHS.GREEN,
                finishPosition: [7,7]
            },
            { 
                id: 2, 
                name: 'Yellow Player', 
                color: COLORS.YELLOW,
                homePositions: [[12,12],[12,13],[13,12],[13,13]],
                startSquare: [8,13],
                path: BOARD_PATHS.YELLOW,
                finishPosition: [7,7]
            },
            { 
                id: 3, 
                name: 'Blue Player', 
                color: COLORS.BLUE,
                homePositions: [[12,1],[12,2],[13,1],[13,2]],
                startSquare: [13,6],
                path: BOARD_PATHS.BLUE,
                finishPosition: [7,7]
            }
        ];

        // Game State
        let scene, camera, renderer, raycaster, mouse;
        let pieces = [];
        let clickablePieces = [];
        let gameState = {
            currentPlayer: 0,
            diceValue: 0,
            canRoll: true,
            movablePieces: [],
            winner: null
        };

        const BOARD_SIZE = 15;
        const CELL_SIZE = 0.6;
        const PIECE_HEIGHT = 0.35;

        // Initialize Three.js
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f0f1e);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 20, 14);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
            mainLight.position.set(10, 20, 10);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            scene.add(mainLight);

            // Colored corner lights
            addCornerLight(COLORS.RED.hex, -4, -4);
            addCornerLight(COLORS.GREEN.hex, -4, 4);
            addCornerLight(COLORS.YELLOW.hex, 4, 4);
            addCornerLight(COLORS.BLUE.hex, 4, -4);

            createBoard();
            createAllPieces();
            updateUI();

            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('click', onBoardClick);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            document.getElementById('dice-button').addEventListener('click', rollDice);
            document.getElementById('restart-button').addEventListener('click', () => location.reload());

            animate();
        }

        function addCornerLight(color, x, z) {
            const light = new THREE.PointLight(color, 0.8, 15);
            light.position.set(x, 3, z);
            scene.add(light);
        }

        function createBoard() {
            // Base platform
            const baseGeo = new THREE.BoxGeometry(BOARD_SIZE * CELL_SIZE + 1.5, 0.4, BOARD_SIZE * CELL_SIZE + 1.5);
            const baseMat = new THREE.MeshStandardMaterial({ 
                color: 0x1a1a2e,
                metalness: 0.6,
                roughness: 0.4
            });
            const base = new THREE.Mesh(baseGeo, baseMat);
            base.position.y = -0.25;
            base.receiveShadow = true;
            scene.add(base);

            // Create cells
            for(let x = 0; x < BOARD_SIZE; x++) {
                for(let z = 0; z < BOARD_SIZE; z++) {
                    const cellGeo = new THREE.BoxGeometry(CELL_SIZE * 0.92, 0.08, CELL_SIZE * 0.92);
                    let cellColor = 0x2a2f4a;

                    // Home areas (corners)
                    if(x <= 3 && z <= 3) cellColor = COLORS.RED.hex;
                    else if(x <= 3 && z >= 11) cellColor = COLORS.GREEN.hex;
                    else if(x >= 11 && z >= 11) cellColor = COLORS.YELLOW.hex;
                    else if(x >= 11 && z <= 3) cellColor = COLORS.BLUE.hex;
                    // Center finish area
                    else if(x >= 6 && x <= 8 && z >= 6 && z <= 8) cellColor = 0xffd93d;
                    // Main path cells
                    else if(isOnMainPath(x, z)) cellColor = 0x3a3f5a;
                    // Home stretch paths
                    else if(isOnHomeStretch(x, z)) {
                        if(x === 6 && z >= 1 && z <= 6) cellColor = COLORS.RED.hex;
                        else if(z === 7 && x >= 1 && x <= 6) cellColor = COLORS.GREEN.hex;
                        else if(x === 8 && z >= 8 && z <= 13) cellColor = COLORS.YELLOW.hex;
                        else if(z === 7 && x >= 8 && x <= 13) cellColor = COLORS.BLUE.hex;
                    }

                    const cellMat = new THREE.MeshStandardMaterial({
                        color: cellColor,
                        metalness: 0.3,
                        roughness: 0.7,
                        emissive: cellColor,
                        emissiveIntensity: 0.15
                    });

                    const cell = new THREE.Mesh(cellGeo, cellMat);
                    const posX = (x - BOARD_SIZE / 2 + 0.5) * CELL_SIZE;
                    const posZ = (z - BOARD_SIZE / 2 + 0.5) * CELL_SIZE;
                    cell.position.set(posX, 0, posZ);
                    cell.receiveShadow = true;
                    scene.add(cell);
                }
            }

            // Add border
            const borderMat = new THREE.MeshStandardMaterial({
                color: 0xffd93d,
                emissive: 0xffd93d,
                emissiveIntensity: 0.4,
                metalness: 0.8,
                roughness: 0.2
            });

            const borderThick = 0.12;
            const boardDim = BOARD_SIZE * CELL_SIZE + 1.5;
            
            const borders = [
                [boardDim, borderThick, borderThick, 0, 0, boardDim/2],
                [boardDim, borderThick, borderThick, 0, 0, -boardDim/2],
                [borderThick, borderThick, boardDim, boardDim/2, 0, 0],
                [borderThick, borderThick, boardDim, -boardDim/2, 0, 0]
            ];

            borders.forEach(([w,h,d,x,y,z]) => {
                const geo = new THREE.BoxGeometry(w,h,d);
                const mesh = new THREE.Mesh(geo, borderMat);
                mesh.position.set(x,y,z);
                scene.add(mesh);
            });
        }

        function isOnMainPath(x, z) {
            // Outer ring path
            if((x === 1 || x === 13) && z >= 0 && z <= 14) return true;
            if((z === 1 || z === 13) && x >= 0 && x <= 14) return true;
            if((x === 6 || x === 8) && (z === 0 || z === 14)) return true;
            if((z === 6 || z === 8) && (x === 0 || x === 14)) return true;
            if(x === 0 && (z >= 1 && z <= 6 || z >= 8 && z <= 13)) return true;
            if(x === 14 && (z >= 1 && z <= 6 || z >= 8 && z <= 13)) return true;
            if(z === 0 && (x >= 6 && x <= 8)) return true;
            if(z === 14 && (x >= 6 && x <= 8)) return true;
            // Middle rows
            if((x === 2 || x === 12) && (z === 6 || z === 7 || z === 8)) return true;
            if((z === 2 || z === 12) && (x === 6 || x === 7 || x === 8)) return true;
            return false;
        }

        function isOnHomeStretch(x, z) {
            if(x === 6 && z >= 1 && z <= 6) return true; // Red
            if(z === 7 && x >= 1 && x <= 6) return true; // Green
            if(x === 8 && z >= 8 && z <= 13) return true; // Yellow
            if(z === 7 && x >= 8 && x <= 13) return true; // Blue
            return false;
        }

        function createAllPieces() {
            PLAYERS.forEach(player => {
                player.pieces = [];
                player.homePositions.forEach((homePos, idx) => {
                    const piece = createPiece(player, homePos, idx);
                    player.pieces.push(piece);
                    pieces.push(piece);
                });
            });
        }

        function createPiece(player, homePos, idx) {
            const geo = new THREE.CylinderGeometry(0.22, 0.22, PIECE_HEIGHT, 32);
            const mat = new THREE.MeshStandardMaterial({
                color: player.color.hex,
                metalness: 0.5,
                roughness: 0.3,
                emissive: player.color.hex,
                emissiveIntensity: 0.25
            });

            const mesh = new THREE.Mesh(geo, mat);
            const [x, z] = homePos;
            const posX = (x - BOARD_SIZE / 2 + 0.5) * CELL_SIZE;
            const posZ = (z - BOARD_SIZE / 2 + 0.5) * CELL_SIZE;
            mesh.position.set(posX, PIECE_HEIGHT / 2 + 0.05, posZ);
            mesh.castShadow = true;

            mesh.userData = {
                playerId: player.id,
                pieceIdx: idx,
                pathPosition: -1, // -1 = in home
                homePos: homePos,
                type: 'piece'
            };

            scene.add(mesh);
            return mesh;
        }

        function rollDice() {
            if(!gameState.canRoll) return;

            gameState.canRoll = false;
            const button = document.getElementById('dice-button');
            button.classList.add('rolling');
            button.disabled = true;

            let rolls = 0;
            const rollInterval = setInterval(() => {
                const temp = Math.floor(Math.random() * 6) + 1;
                button.textContent = ['‚öÄ','‚öÅ','‚öÇ','‚öÉ','‚öÑ','‚öÖ'][temp - 1];
                rolls++;
                
                if(rolls > 8) {
                    clearInterval(rollInterval);
                    gameState.diceValue = Math.floor(Math.random() * 6) + 1;
                    button.textContent = ['‚öÄ','‚öÅ','‚öÇ','‚öÉ','‚öÑ','‚öÖ'][gameState.diceValue - 1];
                    button.classList.remove('rolling');
                    
                    document.getElementById('dice-result').textContent = `Rolled: ${gameState.diceValue}`;
                    
                    setTimeout(handleDiceRoll, 400);
                }
            }, 80);
        }

        function handleDiceRoll() {
            const player = PLAYERS[gameState.currentPlayer];
            gameState.movablePieces = getMovablePieces(player);

            if(gameState.movablePieces.length === 0) {
                updateStatus(`${player.name}: No valid moves!`);
                setTimeout(() => {
                    nextPlayer();
                }, 1500);
            } else {
                updateStatus(`${player.name}: Click a piece to move`);
                document.getElementById('instruction-hint').style.display = 'block';
                highlightMovablePieces();
            }
        }

        function getMovablePieces(player) {
            const movable = [];
            
            player.pieces.forEach((piece) => {
                const pos = piece.userData.pathPosition;
                
                // Can move out of home with a 6
                if(pos === -1 && gameState.diceValue === 6) {
                    movable.push(piece);
                }
                // Can move on path
                else if(pos >= 0) {
                    const newPos = pos + gameState.diceValue;
                    // Check if move is valid (not beyond finish)
                    if(newPos <= player.path.length - 1) {
                        movable.push(piece);
                    }
                }
            });
            
            return movable;
        }

        function highlightMovablePieces() {
            gameState.movablePieces.forEach(piece => {
                animateHighlight(piece);
            });
        }

        function animateHighlight(piece) {
            const startY = piece.position.y;
            const startTime = Date.now();
            
            function bounce() {
                if(gameState.movablePieces.includes(piece) && gameState.canRoll === false) {
                    const elapsed = Date.now() - startTime;
                    const cycle = (elapsed % 1000) / 1000;
                    piece.position.y = startY + Math.sin(cycle * Math.PI * 2) * 0.15;
                    requestAnimationFrame(bounce);
                } else {
                    piece.position.y = startY;
                }
            }
            bounce();
        }

        function onBoardClick(event) {
            if(gameState.canRoll || gameState.movablePieces.length === 0) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(pieces);

            if(intersects.length > 0) {
                const clickedPiece = intersects[0].object;
                
                if(gameState.movablePieces.includes(clickedPiece)) {
                    document.getElementById('instruction-hint').style.display = 'none';
                    movePiece(clickedPiece);
                }
            }
        }

        function movePiece(piece) {
            gameState.movablePieces = []; // Clear highlights
            
            const player = PLAYERS[piece.userData.playerId];
            const currentPos = piece.userData.pathPosition;

            if(currentPos === -1) {
                // Move from home to start position
                piece.userData.pathPosition = 0;
                const targetCell = player.path[0];
                animateMove(piece, targetCell, () => {
                    checkWinAndContinue(piece.userData.playerId);
                });
            } else {
                // Move along path
                const newPos = currentPos + gameState.diceValue;
                piece.userData.pathPosition = newPos;
                const targetCell = player.path[newPos];
                
                animateMove(piece, targetCell, () => {
                    checkCapture(piece, targetCell);
                    checkWinAndContinue(piece.userData.playerId);
                });
            }
        }

        function animateMove(piece, targetCell, callback) {
            const [x, z] = targetCell;
            const targetX = (x - BOARD_SIZE / 2 + 0.5) * CELL_SIZE;
            const targetZ = (z - BOARD_SIZE / 2 + 0.5) * CELL_SIZE;

            const startX = piece.position.x;
            const startZ = piece.position.z;
            const startY = piece.position.y;
            const duration = 600;
            const startTime = Date.now();

            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const eased = easeInOutQuad(progress);

                piece.position.x = startX + (targetX - startX) * eased;
                piece.position.z = startZ + (targetZ - startZ) * eased;
                piece.position.y = startY + Math.sin(progress * Math.PI) * 0.4;

                if(progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    piece.position.y = startY;
                    if(callback) callback();
                }
            }
            animate();
        }

        function checkCapture(piece, targetCell) {
            const player = PLAYERS[piece.userData.playerId];
            
            pieces.forEach(otherPiece => {
                if(otherPiece.userData.playerId === piece.userData.playerId) return;
                
                const otherPos = otherPiece.userData.pathPosition;
                if(otherPos >= 0) {
                    const otherPlayer = PLAYERS[otherPiece.userData.playerId];
                    const otherCell = otherPlayer.path[otherPos];
                    
                    if(otherCell[0] === targetCell[0] && otherCell[1] === targetCell[1]) {
                        // Capture!
                        sendHome(otherPiece);
                        updateStatus(`${player.name} captured ${otherPlayer.name}'s piece!`);
                    }
                }
            });
        }

        function sendHome(piece) {
            const player = PLAYERS[piece.userData.playerId];
            const homePos = piece.userData.homePos;
            const [x, z] = homePos;
            const posX = (x - BOARD_SIZE / 2 + 0.5) * CELL_SIZE;
            const posZ = (z - BOARD_SIZE / 2 + 0.5) * CELL_SIZE;

            piece.position.set(posX, PIECE_HEIGHT / 2 + 0.05, posZ);
            piece.userData.pathPosition = -1;
        }

        function checkWinAndContinue(playerId) {
            if(checkWin(playerId)) {
                gameState.winner = playerId;
                showWinner();
            } else {
                // Check if player rolled 6 for another turn
                if(gameState.diceValue === 6) {
                    setTimeout(() => {
                        gameState.canRoll = true;
                        document.getElementById('dice-button').disabled = false;
                        updateStatus(`${PLAYERS[gameState.currentPlayer].name} rolled 6! Roll again!`);
                    }, 800);
                } else {
                    setTimeout(nextPlayer, 1000);
                }
            }
        }

        function checkWin(playerId) {
            const player = PLAYERS[playerId];
            let finished = 0;
            
            player.pieces.forEach(piece => {
                if(piece.userData.pathPosition >= player.path.length - 1) {
                    finished++;
                }
            });
            
            return finished >= 4;
        }

        function nextPlayer() {
            gameState.currentPlayer = (gameState.currentPlayer + 1) % 4;
            gameState.canRoll = true;
            gameState.movablePieces = [];
            document.getElementById('dice-button').disabled = false;
            document.getElementById('dice-result').textContent = '';
            updateUI();
        }

        function showWinner() {
            const winner = PLAYERS[gameState.winner];
            document.getElementById('winner-name').textContent = winner.name;
            document.getElementById('winner-name').style.color = winner.color.css;
            document.getElementById('winner-modal').style.display = 'flex';
            createConfetti(winner.color.hex);
        }

        function createConfetti(color) {
            for(let i = 0; i < 80; i++) {
                const geo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
                const mat = new THREE.MeshStandardMaterial({ 
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.5
                });
                const confetti = new THREE.Mesh(geo, mat);
                
                confetti.position.set(
                    (Math.random() - 0.5) * 15,
                    8 + Math.random() * 4,
                    (Math.random() - 0.5) * 15
                );
                
                confetti.userData.velocity = {
                    x: (Math.random() - 0.5) * 0.08,
                    y: -0.03 - Math.random() * 0.04,
                    z: (Math.random() - 0.5) * 0.08
                };
                
                scene.add(confetti);
            }
        }

        function updateUI() {
            const playersList = document.getElementById('players-list');
            playersList.innerHTML = '';

            PLAYERS.forEach((player, idx) => {
                const finishedCount = player.pieces.filter(p => 
                    p.userData.pathPosition >= player.path.length - 1
                ).length;
                
                const item = document.createElement('div');
                item.className = 'player-item' + (idx === gameState.currentPlayer ? ' active' : '');
                item.innerHTML = `
                    <div class="player-color" style="background-color: ${player.color.css}"></div>
                    <div class="player-name">${player.name}</div>
                    <div class="player-home-count">${finishedCount}/4</div>
                `;
                playersList.appendChild(item);
            });

            const currentPlayer = PLAYERS[gameState.currentPlayer];
            if(gameState.canRoll) {
                updateStatus(`${currentPlayer.name}: Roll the dice!`);
            }
        }

        function updateStatus(text) {
            document.getElementById('status-text').textContent = text;
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function easeInOutQuad(t) {
            return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
        }

        function animate() {
            requestAnimationFrame(animate);

            // Animate confetti
            scene.children.forEach(child => {
                if(child.userData.velocity) {
                    child.position.x += child.userData.velocity.x;
                    child.position.y += child.userData.velocity.y;
                    child.position.z += child.userData.velocity.z;
                    child.rotation.x += 0.05;
                    child.rotation.y += 0.05;

                    if(child.position.y < -2) {
                        scene.remove(child);
                    }
                }
            });

            // Gentle camera movement
            const time = Date.now() * 0.0001;
            camera.position.x = Math.sin(time * 0.5) * 1.5;

            renderer.render(scene, camera);
        }

        window.addEventListener('load', init);
    </script>
</body>
</html>